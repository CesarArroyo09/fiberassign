\documentclass[10pt]{extarticle}
%\usepackage[7pt]{moresize}
%\fontfamily{<familyname>}\selectfont
\renewcommand{\sfdefault}{phv}
\usepackage{anyfontsize}
\usepackage{verbatim}
\usepackage{authblk}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{multicol}
\usepackage{indentfirst}
\usepackage{pstricks,pstricks-add,pst-math,pst-xkey}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[T1]{fontenc}          %% permet d'utiliser les caractères accentués
\usepackage[utf8]{inputenc} %% permet d'utiliser les caractères accentué
\usepackage{float}
\usepackage{filecontents}
%PGF plot
\usepackage{pgfplots, pgfplotstable}
\usepgfplotslibrary{statistics}
\pgfplotscreateplotcyclelist{mycolorlist}{%
blue\\%
red\\%
brown\\%
teal\\%
violet\\%
cyan\\%
green\\%
black\\%
}
\pgfplotscreateplotcyclelist{mylegend}{Ly-a,Target,LRG,ELG,Fake,Fake,SS,SF}

\usepackage{xifthen}
\newcommand{\getsizes}[2]% width, height
{   \path (current bounding box.south west);
    \pgfgetlastxy{\xsw}{\ysw}
    \path (current bounding box.north east);
    \pgfgetlastxy{\xne}{\yne}
    \pgfmathsetmacro{\picwidth}{(\xne-\xsw)/28.453}
    \pgfmathsetmacro{\picheight}{(\yne-\ysw)/28.453}
    \pgfmathsetmacro{\picxscale}{#1/\picwidth}
    \pgfmathsetmacro{\picyscale}{#2/\picheight}
    \xdef\xsca{\picxscale}
    \xdef\ysca{\picyscale}
}

\newcommand{\xyscaledtikz}[3]% draw commands, width, height
{ \smash{\vphantom{
    \begin{tikzpicture}
        #1
        \getsizes{#2}{#3}
    \end{tikzpicture}
    }}
    \begin{tikzpicture}[xscale=\xsca,yscale=\ysca]
        #1
    \end{tikzpicture}
}

%%%% debut macro %%%%
\newenvironment{changemargin}[2]{\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{0pt}%
\setlength{\rightmargin}{0pt}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{0pt plus 1pt}%
\addtolength{\leftmargin}{#1}%
\addtolength{\rightmargin}{#2}%
}\item }{\end{list}}

%\begin{changemargin}{0cm}{0cm}
%\end{changemargin}

%%%% fin macro %%%%

%Dash lines
\newcommand\Algphasee[1]{%
\Statex\hspace*{-\algorithmicindent}\textbf{#1}%
\vspace*{-.7\baselineskip}\Statex\hspace*{\dimexpr-\algorithmicindent-2pt\relax}\rule{\linewidth}{0.4pt}%
}

\newcommand\Algphase[1]{%
\vspace*{-.7\baselineskip}\Statex\hspace*{\dimexpr-\algorithmicindent-2pt\relax}\rule{\linewidth}{0.4pt}%
\Statex\hspace*{-\algorithmicindent}\textbf{#1}%
\vspace*{-.7\baselineskip}\Statex\hspace*{\dimexpr-\algorithmicindent-2pt\relax}\rule{\linewidth}{0.4pt}%
}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\def\begeq{\begin{equation}}
\def\endeq{\end{equation}}
\def\begeqar{\begin{eqnarray}}
\def\endeqar{\end{eqnarray}}
\def\Rmm{R_{\rm mm}}
\def\Rdeg{R_{\rm deg}}
\def\micron{\mu{\rm m}}
\def\lya{Ly-$\alpha$\ }

\usepackage{geometry}
\geometry{hscale=0.85,vscale=0.85,centering}
\title{Description of fiber assignment code for Mocks}
%\author{Robert Cahn and Louis Garrigue}
\author[1]{Robert N. Cahn\thanks{rncahn@lbl.gov}}
\author[2]{Louis Garrigue\thanks{louis.garrigue@ens.fr}}
\affil[1]{Department of Cosmological Physics, LBNL, Berkeley}
\affil[2]{Département de physique, École normale supérieure, Paris}
\date{\today}

\begin{document}
%\begin{titlepage}
%\end{titlepage}


\maketitle
\begin{center}
  \includegraphics[width = 20mm]{figs/logolbnl.png}\hfill
  \includegraphics[width = 20mm]{figs/logodesi.jpg} \hfill
  \includegraphics[width = 20mm]{figs/logoens.png} 
\end{center}

\begin{comment}
\section{Rules for fiber assignment}
We know the repartition of matter (by repartition of H matter) by pics.
The original catalog of 50M galaxies has only information on the position and the type of the galaxy, which is LRG, ELG or QSO. Those information were given by a previous survey, only based on colors, the redshift wasn't then computed. But there are different types of each one. QSO can be $Ly-\alpha$, target or fake (actually fake ones can be stars for example). A python code generates the file of galaxies, simulating with appropriate probabilities each type, taking into account the fact that there are correlations between positions of galaxies (accordingly with BAO and gravition). When we watch at a QSO and we see that it's a fake or a target, we don't watch at it anymore. But if it's a real one, we try to see it 5 times if it is possible.
The absorption spectrum shows a pic at $\lambda = 1216 Å$. We can deduced the redshift because we receive a wavelenght $\lambda(1+z)$. As spectrometers can only see wavelenghts in the range 380 nm (under, no enough energy is received) - 980 nm, the minimum redshift we can reach is 2.2.
At first, there was as code written by Martin White then Robert Cahn that did an assignment of tilefibers - galaxies in a global way : naïve assignment, improvement (try to reassign some fibers to other ones to assign free ones) and redistribution (do not assign more, but it's to have a better repartition of free fibers on each petal).
We have to avoid correlation not mastered. That's why we don't (at first sight), when we take a new tile, associate 50 free fibers to regions of low QSO density. We would rather assign until there are only 50 free fibers left.
We have to reserve 10 fibers by petal to Standard Stars and 40 to Sky Fibers.
We do the compuation in real time. That means that we do it tile by tile. We can't access the information of all the galaxies because we only have past watched galaxies information. That adds a new constrain. So I rewrote algorithms so that they would compute an optimal assignment for one plate, knowing information on previous one assignments, and knowing information on previously watched galaxies.
\end{comment}

\section{Introduction}
\begin{multicols}{2}
Martin White developed C++ code for fiber assignment over the full 14k sq. deg. footprint.  We first modified Martin's code to incorporate features from Robert's python code, which ran on a restricted 480 sq. deg.. We included the improvement and redistribution steps, which switches fiber assignments to increase the number of galaxies observed. We then adapted the code to compute assignments not globally anymore "knowing all information on galaxies" but plate after plate, as in real experiment.
The samples are taken from Martin's mocks in stored on NERSC at /project/projectdirs/desi/mocks/preliminary/.  From these files we create a single file containing the appropriate mix of ELG, LRG, QSO, SS (Standard Stars) and SF (Sky Fibers) using the python script in git fiberassign/bin/make\_catalog\_starsandsky.py.  In the same place there is python code to produce a mixture of galaxies without any correlations, but with the correct dn/dz.  
  
  The code needs to know the locations of the positioners in the focal plane.  They are given in : \$DESIMODEL/data/focalplane/fiberpos.txt.
  It also needs to know the locations of the centers of the fields in the sky, i.e. the plates, and their order.  The original code written by Martin White provided the option of having the plate centers given in a binary file or an ASCII file.  We are now using the ASCII option by defining ASCIICENTERS at the outset.  If one wants to use the previous binary format, he has to ask it to Robert and adapt it to the new structure. The format is that of \$DESIMODEL/data/footprint/desi-tiles.par, but an alternative ASCII file can be provided. If the executable is {\tt assign} then the calling sequence will look like :
  {\tt./assign galaxies.rdzipn desi-tiles.par fiberpos.txt assignment}
 Here the catalog of targets is in the NERSC directory :
  /projects/projectdirs/desi/mocks/ preliminary/objects\_ss\_sf0.rdzipn the binary file created by {\tt make\_catalog}. The plate centers are provided here by \$DESIMODEL/data/footprint/desi-tiles.par The locations of the positioners are given in \$DESIMODEL/data/focalplane/fiberpos.txt An option not now used is to write the actual assignments to a file here called {\tt assignment}.
  
  
  README.rst gives instructions for running on NERSC. The problem of colliding fiber positioners is addressed in a simplified way. 
  We summarize here the various components of the code to facilitate their modification later.
Here are some features on input galaxies simulated catalog :

\begin{table}[H]\begin{center}
	\caption{Characteristics of galaxy samples as set in make\_catalog\_rnc.py}\label{table:characteristics}
	\begin{tabular}{lcccr}\\ \hline
		Kind&Id&Priority&Nobs&Density/sq.deg.\\ \hline
		Ly-A QSO & 0 & 1 & 5 &  50\\
		Tracer QSO & 1 & 1 & 1& 120\\
		LRG & 2 & 3 &2 & 300\\
		ELG & 3 & 5 & 1 & 2400\\
		Fake QSO & 4 & 1 & 1& 90\\
		Fake LRG & 5 & 3 & 1 & 50\\
		SS & 6 & 2 & 1&  ?\\
		SF & 7 & 4 & 1& ?\\ \hline
	\end{tabular}\end{center}
\end{table}


\section{Source files}
They all consist in a .h and a .cpp file and are in this inscreasing dependency order :
\begin{itemize} 
	\item macros : set as global some parameters of the program
	\item misc : a home-made library of structures (and functions on them) needed to manipulate concerning datas, but independent of them. There are pair (of int), List (of int), Table, Cube, and timing, printing, string conversion, error report items.
	\item structs : structures of the manipulated datas and their members
	\item global : main high-level functions and algorithms used in the program to collect information, assign fibers and print statistics. Important ones are described further
	\item main : neat and quickly understandable code that sum up all steps
\end{itemize} 

\section{Parameters}
They are defined at the begining of the file main.
\begin{itemize} 
	\item parameters sumed-up in the table \ref{table:characteristics}
	\item Npass = 5 number of passes
	\item MinUnused = 50 (not used anymore for the moment) minimum number of unused fibers on each petal
	\item MaxSS = 10 ; MaxSF = 40 maximum number of fibers assigned to SS and SF on a petal
	\item PlateRadius = 1.65 radius of the plate
	\item TotalArea = 15789.0 total scrutinised area of the sky
	\item Collide = 2.1 minimum distance allowed on plate projection of two assigned galaxies on the same plate
	\item NeighborRad = 11.0 maximum distance to consider that two fibers are neighbors
	\item PatrolRad = 6.0 maximum distance, on plate coordinates, that allows a fiber to watch at a galaxy
	\item InterPlate = 200 minimal plate distance between two plates observing the same galaxy
	\item Randomize = false randomize order of plates in making plans
\end{itemize} 


\section{Classes and structures}
They are build in order to be independent to each other, flexible, quickly understandable, in a logical way, and with no redundant information.

\end{multicols}
\begin{table}[H]\begin{center}
	\caption{Classes and structures}\label{tab:structures}
	\begin{tabular}{|l|l|p{12cm}|}\\ \hline
		Structure name & Meaning & Description \\ \hline \hline

		Feat & Features of galaxies & Initialized in the main function, memories priorities, number of observations wished, and types of different galaxies.\\ \hline

		PP & Plate Parameters & Carries positions of fiber positions on the plate, spectrometer correspondence, and neighboring fibers information.\\ 

		onplate & Plate coordinates & Is used for coordinates in the focal plane in mm. The member {\tt id} is used to give the identity of a galaxy. Onplates is vector of onplate.\\ 

		plate & A plate & Peculiarly describes both the location in the sky of the tile in terms of a unit vector derived from RA and DEC. Carries also the Id of the tile, its pass, and the available galaxies it is able to reach. Then Plates is vector of plate, and has all information on tiles.\\ \hline

		galaxy & A galaxy & Information on a galaxy : an {\tt id} that corresponds to table \ref{tab:characteristics}, a position in the sky (in 2 differents ways), and the available tile-fibers that can watch at it. Gals is vector of galaxy and carries all information on galaxies.\\ \hline

		Assignment & An entire assignment & Carries maping of tile-fibers to galaxies, its inverse, galaxies to tile-fibers, and the cube (3d-matrix) of assigned fibers for a kind, a petal and a plate (useful to have fast computations).\\ \hline
	\end{tabular}\end{center}
\end{table}
\begin{multicols}{2}

\section{Functions}
In algorithms, j stands for a plate, k for a fiber, p for a petal, g for a galaxy.

\subsection{Collecting}
{\tt collect\_galaxies\_for\_all} is multithreaded, and for each fiber of each tile, collects reachable galaxies. It uses kdTree and htmTree libraries written by Martin White, because it's absolutelly necessary to do computations in a reasonnable time with supercomputers.

{\tt collect\_available\_tilefibers} computes, using the previous work, available tile-fibers for each galaxy (inverse map)

\subsection{Useful sub-functions for global functions}
{\tt plate\_dist} turns radians into mm on the focal plane, i.e. it is the plate scale as a function of angle.

{\tt change\_coords} is a critical function that combines a galaxy and a particular plate to give the coordinates the galaxy will have in the focal plane when observed as with this tile. It's a rotation in angular coordinates. This ought to be rigorously checked.

{\tt find\_collision} returns the fiber number of a fiber that conflicts with tiblefiber (j,k).  Conflict is defined by two observed galaxies being separated by less than {\tt Collide}, currently set to 2.1 mm.

{\tt ok\_assign\_g\_to\_jk\_nobs and ok\_assign\_tot} checks to see if we can assign g to the tile-fiber (j,k), according to assigning rules described further

{\tt find\_best (j,k)} finds the best reachable galaxy for this fiber, according to assignment rules

\begin{algorithm}[H]
	\caption{Find best(j,k)}\label{euclid}
	\begin{algorithmic}[1]
		\State Initialize a fictive galaxy to -1, called best
		\For {each galaxy available galaxy (for this fiber) g}
		\If {g is better}
		\State $best \gets g$
		\EndIf
		\EndFor
	\end{algorithmic}
\end{algorithm}

{\tt assign\_fiber(j,k)} tries to assign this fiber using find\_best

{\tt improve\_fiber (j0,n,j,k)} if this fiber is unused, tries first to simply assign it, and if it doesn't work, tries to reassigning some used one (jp,kp) where $j0\le jp \le j0+n$. Before : (jp,kp) - g ; (j,k) \& gp free. After : (j,k) - g \& (jp,kp) - gp. The power of this function lies in the fact that j and jp can correspond to different passes.

\begin{algorithm}[H]
	\caption{Improve\_fiber(j0,n,j,k)}\label{euclid}
	\begin{algorithmic}[1]
		\If {k is not assigned}
		\State try to assign\_(j,k)
		\If {k couldn't just be assigned}
		\For {each available galaxy g}
		\If {it's possible to assign g with k}
		\For {each chosen tile-fibers (jp,kp) which choosed g (where $j0\le jp \le j0+n$)}
		\State $gp\leftarrow find\_best(jp,kp)$
		\If {$gp \ne -1$}
		\State Unassign $(jp,kp) \longleftrightarrow g$
		\State Assign $(j,k) \longleftrightarrow g$
		\State Assign $(jp,kp) \longleftrightarrow gp$
		\EndIf
		\EndFor
		\EndIf
		\EndFor
		\EndIf
		\EndIf
	\end{algorithmic}
\end{algorithm}


\subsection{Assigning making a plan}
Here are algorithms that know all information and are able to compute the assignment crossing between plates. It does a plan with only information available by the catalog and by previous seen galaxies. One can use them with size 1 if one wants to do an assignment plate after plate for instance (which shouldn t be called a plan anymore).

The "next" argument means that we treat (in a shuffle order) all next "next" plates (in the right order of tiles) in the plan we make. If it is $-1$, it will deal with all left plates.

{\tt simple\_assign} makes a first simple assignment plan : for each fiber assign to the best available galaxy

\begin{algorithm}[H]
	\caption{Simple\_assign(j0,n)}\label{euclid}
	\begin{algorithmic}[1]
		\For {each plate j from j0 to j0+n in a random order}
		\For {each fiber k in a random order}
		\State try to assign\_fiber(j,k)
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}

{\tt new\_assign\_fibers} makes a first assignment plan trying to assign without SS nor SF, then trying to assign them replacing other kinds

\begin{algorithm}[H]
	\caption{New\_assign\_fibers(j0,n)}\label{euclid}
	\begin{algorithmic}[1]
		\For {each plate j from j0 to j0+n in a random order}
		\For {each petal p of this plate, in a random order}
		\For {each fiber k of this petal, in a random order}
		\State Try assign\_fiber(j,k) where SS and SF are not allowed
		\EndFor
		\For {each unassigned fiber k of this petal}
		\State Try assign\_fiber(j,k) to only SS or SF
		\EndFor
		\If {Number of SS $\le$ 10}
		\State Replace ELG (then LRG) to an SS until there are 10 SS
		\EndIf
		\If {Number of SF $\le$ 40}
		\State Replace ELG (then LRG) to an SF until there are 40 SF
		\EndIf
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}

{\tt improve} improves the plan applying improve\_fiber to all of the fibers that concern it

{\tt improve\_from\_kind (kind)} for every petal, tries to assign unassigned fibers to SS or SF, to release an other fiber (formerly assigned to a SS or SF) that would be reassigned to a regular galaxy (kind is SS or SF when we call it)

\begin{algorithm}[H]
	\caption{Improve\_from\_kind (kind,j0,n)}\label{euclid}
	\begin{algorithmic}[1]
		\For {each plate j from j0 to j0+n in a random order}
		\For {each petal p of this plate, in a random order}
		\For {each unassigned fiber k}
		\For {each available galaxies g of k}
		\For {each fiber kp of p assigned to a galaxy of kind}
		\If {no conflict}
		\State Reassign kp to g
		\State Assign k to a galaxy of kind kind
		\EndIf
		\EndFor
		\EndFor
		\EndFor
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}

{\tt update\_plan\_from\_one\_obs} updates the plan formerly made so that if for example on the previous observation we've watched at a fake QSO, it won't be observed anymore in case it was planed to be observed once or several times again. Released tile-fibers will then be tryed to be reassigned with improve\_fiber

\begin{algorithm}[H]
	\caption{Update\_plan\_from\_one\_observation(j0,end\_plan)}\label{euclid}
	\begin{algorithmic}[1]
		\State get the list of galaxies watched by this plate that are discovered fake or target
		\For {each of those galaxies g}
		\State get the list of planed tile-fibers watching this galaxy further in the plan $j0\le jp \le end$
		\For {each of those tile-fibers (jp,kp)}
		\State Unassign $(jp,kp) \longleftrightarrow g$
		\State run improve\_fiber(j0+1,end-j0,jp,kp)
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}


\subsection{Displaying results}
{\tt results\_on\_inputs} displays some statistics on treated input files (recall input features, print statistics on the number of fibers with 0 galaxies within reach, 1 galaxy within reach etc. out to 19 galaxies within reach ; number of available tile-fibers for a galaxy, ...)

{\tt display\_results} writes some statistics and provides the tex-formatted results to make Table \ref{tab:full14k}

{\tt print\_free\_fibers} print histograms on free fibers towards/regarding petals, for everything, for only SS and for only SF


\subsection{Other not used anymore functions}
They are redistribution function (redistribution of galaxies (simply or by kind), tile-fibers) used in previous development of the program. We let them here because they can be useful for further develop,ent of the code (redistributing assignment can add new degrees of freedom for an other improvement function execution for example).


\section{Rules of assignment}
\begin{itemize}
	\item of course, a tile-fiber is only assigned once
	\item a galaxy can't be assigned more than once in a pass
	\item two observed galaxies can't be separated by less than {\tt Collide} (set by find\_collision)
	\item in last pass, only ELG, SS and SF are scrutinised
	\item there can't be more than 10 fibers assigned to SS on a petal
	\item there can't be more than 40 fibers assigned to SF on a petal
	\item basically, we choose best galaxy from at the same time available, watched less than maxgoal(kind) times and unassigned ones. Amongst them, we take those which has the least priority, and then the one which has been seen the least number of times
\end{itemize}

In reality we only know the basic type (QSO, LRG, ELG, SS, SF) of the galaxies of the catalog. The precise type is only infered by a simulation coded in python, but is generated with randomness. So in the algorithms, we can know the nature of the object only when it has been watched once at least.
There are two way of assignment : either watch tile after tile and foresee the assignment of the tile just before watching it ; otherwise, we can make a plan for a definite number of next tiles. In such a plan, we try to optimize assignment, but of course, we can't know the precise type (fake, ...) so it is possible to foresee to observe for example 4 times a fake QSO. We won't do it, so after having planed, when we begin to apply it and do the real observation, if we have just previously observed a fake QSO, we will remove further observations in this plan. We then try to assign the released tile-fibers. In the code, a difficulty was optimization at this point : we could have replaned everything in the plan after an update of information, but we can't because that would take too much time. So we only try to reassign released tile-fibers.

The idea is to get most information possible in the first pass, assigning independently tile after tile, and then, after this first pass, make a plan for everything else, when we have information on most of the QSO and LRG (the only kinds we want to observe several times). The plan will be better that way, because we do less mistakes than if we would do it from the begining.


\section{Main}
 The calling sequence is {\tt assign  <galaxy> <plate\_centers> <fiberpos> <assignment>}. The last of these is the file to which we would write all the final galaxy assignments, but this is generally suppressed since we aren't using it yet.
 

 {\tt main} proceeds by taking important parameters, features of galaxies, reading in the galaxies to make G, the positions of the fibers on the plate to make pp, the plate centers and positioner locations to make P. 
 
We then collect available galaxies for each fiber for each plate, and compute the inverse map.
 
We next, tile after tile, do the assignment of galaxies. We have tried several strategies : making several plans, use simple assignment, use complexe one, improve several times, in several ways, etc... Here is the one which gives the best results.


\begin{algorithm}[H]
	\caption{Assignment in main program}\label{euclid}
	\begin{algorithmic}[1]
		\Algphasee{Phase I - Assigning plates after plates}
		\For {each plate j until 2000}
		\State Assign for one plate(j)
		\State Improve SS
		\State Improve SF
		\State Real observation is here
		\EndFor
	\end{algorithmic}

	\begin{algorithmic}[1]
		\Algphase{Phase II - Make a plan}
		\State Run, globally, on the list plates from j0 to j :
		\State Assign fibers
		\State Improve
		\State Improve SF
		\State Improve SS
	\end{algorithmic}

	\begin{algorithmic}[1]
		\Algphase{Phase III - Applying the plan}
		\For {each plate j of the plan, in order}
		\State Real observation is here
		\State Update information collected on previous just watched tile
		\State Update\_plan\_from\_one\_observation(j)
		\EndFor
	\end{algorithmic}
\end{algorithm}

\section{Results}
\subsection{Results on the input catalog}

\begin{figure}[H]\begin{center}\begin{tikzpicture}[scale=1.1]\begin{semilogyaxis}[const plot, stack plots=y, enlarge x limits=false,xlabel={},ylabel={},cycle list name=mycolorlist,legend entries={QSO Ly-$\alpha$,QSO Tracer,LRG,ELG,Fake QSO,Fake LRG,SS,SF}] 
\addplot coordinates{(0,48860818)(1,4272723)(2,190374)(3,5927)(4,154)(5,4)(6,0)} 
 ; 
\addplot coordinates{(0,43223771)(1,9067745)(2,965034)(3,69390)(4,3866)(5,185)(6,9)(7,0)} 
 ; 
\addplot coordinates{(0,32284811)(1,15577500)(2,4321212)(3,931734)(4,176391)(5,31521)(6,5554)(7,1058)(8,166)(9,46)(10,6)(11,1
)(12,0)} 
 ; 
\addplot coordinates{(0,1023976)(1,3785704)(2,7247666)(3,9560878)(4,9736045)(5,8168407)(6,5881360)(7,3734704)(8,2133759)(9,11
13331)(10,536458)(11,240432)(12,102174)(13,40878)(14,15616)(15,5658)(16,1914)(17,715)(18,227)(19,66)(20,24)(21,7)(22,0)(23,0)
(24,0)(25,0)(26,1)(27,0)} 
 ; 
\addplot coordinates{(0,45554172)(1,7176220)(2,568334)(3,29999)(4,1229)(5,44)(6,2)(7,0)} 
 ; 
\addplot coordinates{(0,48857531)(1,4278420)(2,188192)(3,5725)(4,131)(5,1)(6,0)} 
 ; 
\addplot coordinates{(0,41728443)(1,10233745)(2,1258373)(3,102934)(4,6208)(5,280)(6,15)(7,2)(8,0)} 
 ; 
\addplot coordinates{(0,4616745)(1,11260225)(2,13774643)(3,11257056)(4,6913988)(5,3403210)(6,1399769)(7,494264)(8,153927)(9,4
2449)(10,10742)(11,2354)(12,523)(13,87)(14,16)(15,2)(16,0)} 
 ; 
\end{axis}\end{tikzpicture}\end{center}\caption{Available galaxies (by kind) for a TF}\end{figure}


\begin{figure}[H]\begin{center}\begin{tikzpicture}[scale=1.1]\begin{semilogyaxis}[const plot, stack plots=y, enlarge x limits=false,xlabel={},
ylabel={},cycle list name=mycolorlist] 
\addplot coordinates{(0,1221)(1,10791)(2,12456)(3,22479)(4,68609)(5,178598)(6,221698)(7,160186)(8,76194)(9,26755)(10,7327)(11
,1848)(12,389)(13,73)(14,15)(15,4)(16,0)}; 
\addplot coordinates{(0,3026)(1,25933)(2,30158)(3,53496)(4,164665)(5,430022)(6,533620)(7,382218)(8,184066)(9,63875)(10,18081)
(11,4322)(12,919)(13,181)(14,36)(15,1)(16,0)(17,0)(18,1)(19,0)}; 
\addplot coordinates{(0,7827)(1,65268)(2,75612)(3,133924)(4,411745)(5,1070352)(6,1325440)(7,952661)(8,454940)(9,159962)(10,44
925)(11,10781)(12,2357)(13,443)(14,88)(15,15)(16,3)(17,0)}; 
\addplot coordinates{(0,62377)(1,525986)(2,608551)(3,1082678)(4,3324320)(5,8631364)(6,10712696)(7,7694215)(8,3674573)(9,12877
29)(10,359236)(11,86042)(12,18611)(13,3706)(14,732)(15,130)(16,32)(17,2)(18,0)}; 
\addplot coordinates{(0,2275)(1,19738)(2,22979)(3,40711)(4,124605)(5,322045)(6,399710)(7,286461)(8,136996)(9,47975)(10,13427)
(11,3229)(12,692)(13,137)(14,27)(15,3)(16,2)(17,0)}; 
\addplot coordinates{(0,1211)(1,10884)(2,12706)(3,22600)(4,68818)(5,178630)(6,222554)(7,160085)(8,75931)(9,26473)(10,7337)(11
,1763)(12,367)(13,77)(14,12)(15,2)(16,0)}; 
\addplot coordinates{(0,3625)(1,30274)(2,35024)(3,63126)(4,193433)(5,500614)(6,623090)(7,446163)(8,213512)(9,74612)(10,20670)
(11,4996)(12,1077)(13,197)(14,38)(15,8)(16,2)(17,1)(18,0)}; 
\addplot coordinates{(0,35713)(1,303217)(2,353577)(3,629933)(4,1932755)(5,5008249)(6,6217942)(7,4470161)(8,2134168)(9,747845)
(10,207971)(11,49733)(12,10758)(13,2121)(14,409)(15,70)(16,10)(17,2)(18,0)}; 
\end{axis}\end{tikzpicture}\end{center}\caption{Available tile-fibers for a galaxy (by kind)}\end{figure}


\subsection{Results of the assignment}
We run the program with all information (prior knowledge of information on fake, target, etc) to compare with realistic simulation, this result is interesting.

The results are then written using {\tt display\_results} and {\tt print\_free\_fibers}.

We present several strategies and can compare results from one to another. Here is the strategy where we first look at 2000 tiles, tile after tile runing simple\_assign on each tile without plan, and we then do a plan for all left tiles.

We present percentage of improvement in function of iteration of improvement functions.


\begin{figure}[H]\begin{center}\begin{tikzpicture}[scale=1.1]\begin{semilogyaxis}[const plot, stack plots=y, enlarge x limits=false,xlabel={},
ylabel={},cycle list name=mycolorlist] 
\addplot coordinates{(0,31955)(1,10887)(2,6656)(3,5517)(4,4927)(5,4573)(6,4183)(7,3870)(8,3566)(9,3333)(10,3114)(11,2827)(12,
2511)(13,2299)(14,2096)(15,1905)(16,1744)(17,1555)(18,1346)(19,1186)(20,1054)(21,940)(22,748)(23,663)(24,563)(25,448)(26,388)
(27,332)(28,267)(29,235)(30,187)(31,159)(32,138)(33,91)(34,80)(35,53)(36,55)(37,34)(38,30)(39,22)(40,28)(41,18)(42,19)(43,7)(
44,6)(45,10)(46,7)(47,1)(48,3)(49,3)(50,1)(51,2)(52,1)(53,1)(54,4)(55,1)(56,0)(57,1)(58,3)(59,1)(60,2)(61,0)(62,2)(63,1)(64,0
)(65,0)(66,0)(67,0)(68,0)(69,0)(70,0)(71,0)(72,0)(73,0)(74,0)(75,1)(76,0)} 
 ; 
\end{axis}\end{tikzpicture}\end{center}\caption{$#$ of petals with that many free fibers}\end{figure}
 
\begin{table}[H]\begin{center}
\begin{tabular}{l|rrrrrrr}
	~ &               0 &         1 &       2 &      3 &      4 &     5 &         6 \\ \hline
  0   &    22,837 &   414,719 & 238,589 & 75,637 & 28,393 & 8,468 &   788,643 \\ 
  1   & 1,874,315 &    20,305 &       0 &      0 &      0 &     0 & 1,894,620 \\ 
  2   & 3,901,902 &   567,892 & 246,549 &      0 &      0 &     0 & 4,716,343 \\ 
  3   &29,404,671 & 8,668,309 &       0 &      0 &      0 &     0 &38,072,980 \\ 
  4   & 1,405,734 &    15,278 &       0 &      0 &      0 &     0 & 1,421,012 \\ 
  5   &   753,347 &    36,103 &       0 &      0 &      0 &     0 &   789,450 \\ 
  6   & 1,066,600 & 1,143,862 &       0 &      0 &      0 &     0 & 2,210,462 \\ 
  7   & 4,266,400 &17,838,234 &       0 &      0 &      0 &     0 &22,104,634 \\ 
\end{tabular}
\caption{Remaining observations (id on lines, nobs left on rows) with total}\label{tab:full14k}
\end{center}
 \end{table}


\begin{table}[H]\begin{center} 
\begin{tabular}{l|rr}
	~ &         0 &      1 \\ \hline
  0   & 98.926 & 67.673 \\ 
  1   & 98.928 & 98.928 \\ 
  2   & 94.772 & 88.752 \\ 
  3   & 77.232 & 77.232 \\ 
  4   & 98.924 & 98.924 \\ 
  5   & 95.426 & 95.426 \\ 
  6   & 48.252 & 48.252 \\ 
  7   & 19.300 & 19.300 \\ 
\end{tabular}
\caption{Percentages of once observed, and with ponderation} 
\end{center}\end{table}


\begin{table}[H]\begin{center}
\caption{Id on lines. (Per square degrees) Total, Fibers Used, Available, Percent of observations}
\begin{tabular}{l|rrrr} 
   Id &          0  &           1  &           2  &           3 \\ \hline
   0  &      49.457  &     168.796  &      49.948  &      99.015   \\
   1  &     118.275  &     118.275  &     119.996  &      98.565   \\
   2  &     283.469  &     528.792  &     298.711  &      94.897   \\
   3  &    1,705.31  &    1,705.31  &    2,411.36  &      70.719   \\
   4  &      88.709  &      88.709  &      90.000  &      98.565   \\
   5  &      47.734  &      47.734  &         50,  &      95.468   \\
   6  &      67.553  &      67.553  &        14,0  &      48.252   \\
   7  &     270.213  &     270.213  &       14,00  &      19.300   \\
\end{tabular}\end{center}
 \end{table}

 Besides, we have indeed exactly 10 SS and 40 SF per petal.

\section{Possible improvements}
The optimum would be closer if we would replan globally every left tile after each update of information on galaxies (after observation). It's not possible because that would be long to compute (several hours).
We could seek for the best galaxy in improve\_fiber instead of taking the first one which fits.
\end{multicols}
\end{document}
