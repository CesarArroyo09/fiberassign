\documentclass{article}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{multicol}
\usepackage{indentfirst}
\usepackage{pstricks,pstricks-add,pst-math,pst-xkey}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\newcommand\Algphasee[1]{%
\Statex\hspace*{-\algorithmicindent}\textbf{#1}%
\vspace*{-.7\baselineskip}\Statex\hspace*{\dimexpr-\algorithmicindent-2pt\relax}\rule{\textwidth}{0.4pt}%
}

\newcommand\Algphase[1]{%
\vspace*{-.7\baselineskip}\Statex\hspace*{\dimexpr-\algorithmicindent-2pt\relax}\rule{\textwidth}{0.4pt}%
\Statex\hspace*{-\algorithmicindent}\textbf{#1}%
\vspace*{-.7\baselineskip}\Statex\hspace*{\dimexpr-\algorithmicindent-2pt\relax}\rule{\textwidth}{0.4pt}%
}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\def\begeq{\begin{equation}}
\def\endeq{\end{equation}}
\def\begeqar{\begin{eqnarray}}
\def\endeqar{\end{eqnarray}}
\def\Rmm{R_{\rm mm}}
\def\Rdeg{R_{\rm deg}}
\def\micron{\mu{\rm m}}
\def\lya{Ly-$\alpha$\ }

\usepackage{geometry}
\geometry{hscale=0.85,vscale=0.85,centering}
\title{Description of fiber assignment code for Mocks}
\author{Robert Cahn and Louis Garrigue}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

Martin White developed C++ code for fiber assignment over the full 14k sq. deg. footprint.  We first modified Martin's code to incorporate features from Robert's python code, which ran on a restricted 480 sq. deg.. We included the improvement and redistribution steps, which switches fiber assignments to increase the number of galaxies observed. We then adapted the code to compute assignments not globally anymore "knowing all information on galaxies" but plate after plate, as in real experiment.
The samples are taken from Martin's mocks in stored on NERSC at $/project/projectdirs/desi/mocks/preliminary/$.  From these files we create a single file containing the appropriate mix of ELG, LRG, QSO, SS (Standard Stars) and SF (Sky Fibers) using the python script in svn $/code/survey/fiberassignment/FA\_Bob/trunk/bin/make\_catalog\_rnc.py$.  In the same place there is python code to produce a mixture of galaxies without any correlations, but with the correct dn/dz.  
  
  The code needs to know the locations of the positioners in the focal plane.  They are given in :
  
  $ \$DESIMODEL/data/focalplane/fiberpos.txt$
  It also needs to know the locations of the centers of the fields in the sky, i.e. the plates, and their order.  The original code written by Martin White provided the option of having the plate centers given in a binary file or an ASCII file.  We are now using the ASCII option by defining ASCIICENTERS at the outset.  If one wants to use the previous binary format, he has to ask it to Robert and adapt it to the new structure. The format is that of $\$DESIMODEL/data/footprint/desi-tiles.par$, but an alternative ASCII file can be provided. If the executable is {\tt assign} then the calling sequence will look like :
  
  {\tt./assign objects0.rdzipn desi-tiles.par fiberpos.txt assignment}
 
 Here the catalog of targets is in the NERSC directory :
  $/projects/projectdirs/desi/mocks/preliminary/objects\_ss\_sf0.rdzipn$ the binary file created by {\tt make\_catalog}.  The plate centers are provided here by  $\$DESIMODEL/data/footprint/desi-tiles.par$    The locations of the positioners are given in $ \$DESIMODEL/data/footprint/desi-tiles.par$  An option not now used is to write the actual assignments to a file here called {\tt assignment}.
  
  
  README.rst gives instructions for running on NERSC.  The problem of colliding fiber positioners is addressed in a simplified way. 
  We summarize here the various components of the code to facilitate their modification later.
Here are some features on input galaxies simulated catalog :

\begin{table}\begin{center}
	\caption{Characteristics of galaxy samples as set in make\_catalog\_rnc.py}\label{tab:characteristics}
	\begin{tabular}{lcccr}\\ \hline
		Kind&Id&Priority&Nobs&Density/sq.deg.\\ \hline
		Ly-A QSO & 0 & 1 & 5 &  50\\
		Tracer QSO & 1 & 1 & 1& 120\\
		LRG & 2 & 3 &2 & 300\\
		ELG & 3 & 5 & 1 & 2400\\
		Fake QSO & 4 & 1 & 1& 90\\
		Fake LRG & 5 & 3 & 1 & 50\\
		SS & 6 & 2 & 1&  ?\\
		SF & 7 & 4 & 1& ?\\ \hline
	\end{tabular}\end{center}
\end{table}


\section{Source files}
They all consist in a .h and a .cpp file and are in this inscreasing dependency order :
\begin{itemize} 
	\item macros : set as global some parameters of the program
	\item misc : a home-made library of structures (and functions on them) needed to manipulate concerning datas, but independent of them. There are pair (of int), List (of int), Table, Cube, and timing, printing, string conversion, error report items.
	\item structs : structures of the manipulated datas and their members
	\item global : main high-level functions and algorithms used in the program to collect information, assign fibers and print statistics. Important ones are described further
	\item main : neat and quickly understandable code that sum up all steps
\end{itemize} 

\section{Parameters}
They are defined at the begining of the file main.
\begin{itemize} 
	\item parameters sumed-up in the table \ref{tab:characteristics},
	\item Npass = 5 number of passes
	\item MinUnused = 50 (not used anymore for the moment) minimum number of unused fibers on each petal
	\item MaxSS = 10 ; MaxSF = 40 maximum number of fibers assigned to SS and SF on a petal
	\item PlateRadius = 1.65 radius of the plate
	\item TotalArea = 15789.0 total scrutinised area of the sky
	\item Collide = 2.1 minimum distance allowed on plate projection of two assigned galaxies on the same plate
	\item NeighborRad = 11.0 maximum distance to consider that two fibers are neighbors
	\item PatrolRad = 6.0 maximum distance, on plate coordinates, that allows a fiber to watch at a galaxy
\end{itemize} 


\section{Classes and structures}
They are build in order to be independent to each other, flexible, quickly understandable, in a logical way, and with no redundant information.

\begin{table}\begin{center}
	\caption{Classes and structures}\label{tab:structures}
	\begin{tabular}{|l|l|p{12cm}|}\\ \hline
		Structure name & Meaning & Description \\ \hline\hline

		Feat & Features of galaxies & Initialized in the main function, memories priorities, number of observations wished, and types of different galaxies.\\ \hline

		PP & Plate Parameters & Carries positions of fiber positions on the plate, spectrometer correspondence, and neighboring fibers information.\\ 

		onplate & Plate coordinates & Is used for coordinates in the focal plane in mm. The member {\tt id} is used to give the identity of a galaxy. Onplates is vector of onplate.\\ 

		plate & A plate & Peculiarly describes both the location in the sky of the tile in terms of a unit vector derived from RA and DEC. Carries also the Id of the tile, its pass, and the available galaxies it is able to reach. Then Plates is vector of plate, and has all information on tiles.\\ \hline

		galaxy & A galaxy & Information on a galaxy : an {\tt id} that corresponds to table \ref{tab:characteristics}, a position in the sky (in 2 differents ways), and the available tile-fibers that can watch at it. Gals is vector of galaxy and carries all information on galaxies.\\ \hline

		Assignment & An entire assignment & Carries maping of tile-fibers to galaxies, its inverse, galaxies to tile-fibers, and the cube (3d-matrix) of assigned fibers for a kind, a petal and a plate (useful to have fast computations).\\ \hline
	\end{tabular}\end{center}
\end{table}



\section{Functions of global}
{\tt plate\_dist(const double theta)} turns radians into mm on the focal plane, i.e. it is the plate scale as a function of angle.

{\tt change\_coords} is a critical function that combines a galaxy and a particular plate to give the coordinates the galaxy will have in the focal plane when observed as with this tile. It's a rotation in angular coordinates. This ought to be rigorously checked.

{\tt int find\_collision} returns the fiber number of a fiber that conflicts with tiblefiber (j,k).  Conflict is defined by two observed galaxies being separated by less than {\tt Collide}, current set to 2.1 mm.

{\tt bool  ok\_assign\_g\_to\_jk\_nobs} checks to see if we can assign g to the tile-fiber (j,k), according to assigning rules described further

\subsection{Collecting}
{\tt collect\_galaxies\_for\_all} is written for multithreaded, and for each fiber of each tile, collects reachable galaxies. It uses kdTree and htmTree libraries written by Martin White, that as absolutelly necessary to do computations in a reasonnable time with supercomputers.

{\tt collect\_available\_tilefibers} computes, using the previous work, available tile-fibers for each galaxy (inverse map)

\subsection{Assigning with all information}
Here are algorithms that know all information and are able to compute the assignment crossing between plates (so unrealistic, but interesting to compare its "ideal" results to real assignment ones)

{\tt assign\_fibers} makes a first assignment of all fibers of all plates, in a shuffled order

{\tt improve} improves the previously made first assignment. In a shuffled order, try to use unused fibers by reassigning some used one. Before : (jp,kp) - g ; (j,k) \& gp free. After : (j,k) - g \& (jp,kp) - gp.

{\tt redistribute} redistrubte assignments trying to get at least 500 free fibers on each plate. We look first at plates with too few free fibers. Before : (j,k) - g, with Sp(k) too much used. After : (jreassign,kreassign) - g \& (j,k) free, such that (jreassign,kreassign) comes from most unused (ji,ki). Reassign if this is improvement.

\subsection{Assigning tile after tile}
{\tt assign\_fibers\_for\_one} makes a first assignment of all fibers on one plate, with only information on previous watched galaxies

\subsection{Displaying results}
{\tt void results\_on\_inputs} displays some statistics on treated input files (recall input features, print statistics on the number of fibers with 0 galaxies within reach, 1 galaxy within reach etc. out to 19 galaxies within reach ; number of available tile-fibers for a galaxy, ...)

{\tt void display\_results} writes some statistics and provides the tex-formatted results to make Table \ref{tab:full14k}

{\tt print\_free\_fibers} print histograms on free fibers towards/regarding petals, for everything, for on ly SS and for only SF

{\tt conflicts} returns a complete list of all conflicts display them, a list of triplets (j,k,kp). There are no conflicts engendered by our algorithms.




\section{Rules of assignment}
\begin{itemize}
	\item of course, a tile-fiber is only assigned once
	\item a galaxy can't be assigned more than once in a pass
	\item two observed galaxies can't be separated by less than {\tt Collide} (set by find\_collision)
	\item in last pass, only ELG, SS and SF are scrutinised
	\item there can't be more than 10 fibers assigned to SS on a petal
	\item there can't be more than 40 fibers assigned to SF on a petal
	\item basically, we choose best galaxy from at the same time available, watched less than maxgoal(kind) times and unassigned ones. Amongts them, we take those which has the least priority, and then the one which has been seen the least number of times
\end{itemize}

In reality we only know the basic type (QSO, LRG, ELG, SS, SF) of the galaxies of the catalog. The precise type is only infered by a simulation coded in python, but is generated with randomness. So in the algorithms, we can know the nature of the object only when it has been watched once at least.
There are two way of assignment : either watch tile after tile and foresee the assignment of the tile just before watching it ; otherwise, we can make a plan for a definite number of next tiles. In such a plan, we try to optimize assignment, but of course, we can't know the precise type (fake, ...) so it is possible to foresee to observe for example 4 times a fake QSO. We won't do it, so after having planed, when we begin to apply it and do the real observation, if we have just previously observed a fake QSO, we will remove further observations in this plan. We then try to assign the released tile-fibers. In the code, a difficulty was optimization at this point : we could have replaned everything in the plan after an update of information, but we can't because that would take too much time. So we only try to reassign released tile-fibers.

The idea is to get most information possible in the first pass, assigning independently tile after tile, and then, after this first pass, make a plan for everything else, when we have information on most of the QSO and LRG (the only kinds we want to observe several times). The plan will be better that way, because we do less mistakes than if we would do it from the begining.

In algorithms, j stands for a plate, k for a fiber, p for a petal, g for a galaxy.

\begin{algorithm}
	\caption{Assign for one plate}\label{euclid}
	\begin{algorithmic}[1]
		\Procedure{best}{$j,k$}
		\State Initialize a fictive galaxy to -1, called best
		\State Take all available galaxies for this fiber
		\For {each galaxy g}
		\If {g is better}
		\State $best \gets g$
		\EndIf
		\EndFor
		\EndProcedure

		\Procedure{Assign for one plate}{$j$}
		\For {each fiber k in a random order}
		\State Take g = best(j,k)
		\If {$g\ne-1$}
		\State Assign g to (j,k)
		\EndIf
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Algorithms for plan}\label{euclid}
	\begin{algorithmic}[1]
		\Procedure{Improve kind}{}
		\For {each fiber k in a random order}
		\State Take g = best(j,k)
		\If {$g\ne-1$}
		\State Assign g to (j,k)
		\EndIf
		\EndFor
		\EndProcedure

		\Procedure{Update\_plan\_from\_one\_observation}{$j$}
		\For {each fiber k in a random order}
		\If {k was assigned, in j, to an actually fake (or target) galaxy g}
		\State unassign g from (jp,kp) in further plates in the current assignment plan, and try to reassign (jp,kp) (to a best galaxy)
		\EndIf
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}





\section{Main}
 The calling sequence is {\tt assign  <galaxy> <plate\_centers> <fiberpos> <assignment>}. The last of these is the file to which we would write all the final galaxy assignments, but this is generally suppressed since we aren't using it yet.
 
 {\tt main} proceeds by taking important parameters, features of galaxies, reading in the galaxies to make G, the positions of the fibers on the plate to make pp, the plate centers and positioner locations to make P. 
 

We then collect available galaxies for each fiber for each plate, and compute the inverse map.
 
We next, tile after tile, do the assignment of galaxies, by calling {\tt assign\_fibers\_for\_one}.

\begin{algorithm}
	\caption{Assignment in main program}\label{euclid}
	\begin{algorithmic}[1]
		\Algphasee{Phase I - Assigning plates after plates}
		\For {each plate j until 2000}
		\State Assign for one plate(j)
		\State Improve SS
		\State Improve SF
		\State Real observation is here
		\EndFor
	\end{algorithmic}

	\begin{algorithmic}[1]
		\Algphase{Phase II - Make a plan}
		\State Run, globally, on the list plates from j0 to j :
		\State Assign fibers
		\State Improve
		\State Improve SF
		\State Improve SS
	\end{algorithmic}

	\begin{algorithmic}[1]
		\Algphase{Phase III - Applying the plan}
		\For {each plate j of the plan, in order}
		\State Real observation is here
		\State Update information collected on previous just watched tile
		\State Update\_plan\_from\_one\_observation(j)
		\EndFor
	\end{algorithmic}
\end{algorithm}

The results are then written using {\tt display\_results} and {\tt print\_free\_fibers}.
 
\begin{table}[h]\begin{center}
\caption{Remaining observations (id on lines, nobs left on rows) with total}\label{tab:full14k}
\begin{tabular}{l|rrrrrrr}
	Id &      0  &           1  &           2  &           3  &           4  &           5  & total\\ \hline
   0  &           0  &     443,259  &     240,890  &      72,694  &      24,033  &       7,767  &     788,643\\
   1  &   1,867,438  &      27,182  &           0  &           0  &           0  &           0  &   1,894,620\\
   2  &   3,873,418  &     602,268  &     240,657  &           0  &           0  &           0  &   4,716,343\\
   3  &  26,925,090  &  11,147,890  &           0  &           0  &           0  &           0  &  38,072,980\\
   4  &   1,400,629  &      20,383  &           0  &           0  &           0  &           0  &   1,421,012\\
   5  &     753,676  &      35,774  &           0  &           0  &           0  &           0  &     789,450\\
   6  &   1,066,600  &   1,143,862  &           0  &           0  &           0  &           0  &   2,210,462\\
   7  &   4,266,400  &  17,838,234  &           0  &           0  &           0  &           0  &  22,104,634\\
\end{tabular}\end{center}
 \end{table}

\begin{table}[h]\begin{center}
\caption{Id on lines. (Per square degrees) Total, Fibers Used, Available, Percent of observations}
\begin{tabular}{l|rrrr} 
   Id &          0  &           1  &           2  &           3 \\ \hline
   0  &      49.457  &     168.796  &      49.948  &      99.015   \\
   1  &     118.275  &     118.275  &     119.996  &      98.565   \\
   2  &     283.469  &     528.792  &     298.711  &      94.897   \\
   3  &    1,705.31  &    1,705.31  &    2,411.36  &      70.719   \\
   4  &      88.709  &      88.709  &      90.000  &      98.565   \\
   5  &      47.734  &      47.734  &         50,  &      95.468   \\
   6  &      67.553  &      67.553  &        14,0  &      48.252   \\
   7  &     270.213  &     270.213  &       14,00  &      19.300   \\
\end{tabular}\end{center}
 \end{table}

\section{Possible improvements}
The optimum would be closer if we would replan globally every left tile after each update of information on galaxies (after observation). It's not possible because that would be long to compute (several hours).

\end{document}
