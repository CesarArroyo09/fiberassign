#!/usr/bin/env python

"""
Script handling fiberassign inputs
"""

import sys, os, time
import argparse
import desimodel.io
import numpy as np
import datetime
from desitarget.targetmask import desi_mask
from astropy.table import Table, join
import fitsio
import glob
import desimodel.focalplane
import tempfile
import shutil
import subprocess

# Get version string from fiberassign_exec
cmd ="fiberassign_exec --version"
version = subprocess.check_output(cmd.split()).strip().decode()

parser = argparse.ArgumentParser()
parser.add_argument("--mtl", type=str,  help="input targets (FITS file)",required=True)
parser.add_argument("--sky", type=str,  help="input sky positions (FITS file)",required=True)
parser.add_argument("--stdstar", type=str,  help="input std stars (FITS file)")
parser.add_argument("--fibstatusfile", type=str,  help="list of positioners and its status (ECSV or txt file)")
parser.add_argument("--footprint", type=str,  help="list of tiles defining the footprint (FITS file)")
parser.add_argument("--positioners", type=str,  help="list of positioners on the focal plane (FITS file)")


parser.add_argument("--surveytiles", type=str,  help="set of tiles to run fiberassign on (text file)")

parser.add_argument("--telra", type=float, help="Right Ascension of arbitrary pointing - overrides --surveytiles")
parser.add_argument("--teldec", type=float, help="Declination of arbitrary pointing - overrides --surveytiles")
parser.add_argument("--tileid", type=int, help="Integer ID of arbitrary pointing - overrides --surveytiles")
parser.add_argument("--tileobsconditions", type=int, help="Mask describing observing program (DARK:1, GRAY:2, BRIGHT:4) - overrides --surveytiles")

parser.add_argument("--outdir", type=str,  help="output directory (default = ./)", default="./")
parser.add_argument("--starmask", type=int,  help="integer mask defining standard stars")
parser.add_argument("--rundate", type=str,  help="run date [YYYY-MM-DD]")
parser.add_argument("--gfafile", type=str, help="GFA file (FITS tile)")
parser.add_argument("--nstarpetal", type=int, help="number of standard stars per petal (default=10)", default=10)
parser.add_argument("--nskypetal", type=int, help="number of sky fibers per petal (default=40)", default=40)

parser.add_argument("--nocleanup", dest='cleanup', default=True, action='store_false')
parser.add_argument("--overwrite", action='store_true', help='overwrite pre-existing output files')
parser.add_argument("--version",help='Print C code version and exit',
                    action='version',version='{:s}'.format(version))

args = parser.parse_args()

if args.footprint is None:
    args.footprint =  desimodel.io.findfile('footprint/desi-tiles.fits')

if args.positioners is None:
    args.positioners = desimodel.io.findfile('focalplane/fiberpos-all.fits')

tmp_surveytiles = None
if args.surveytiles is None:
    data = desimodel.io.load_tiles(tilesfile=args.footprint)
    tmp_surveytiles = os.path.join(args.outdir, "tmp_surveytiles.txt")
    np.savetxt(tmp_surveytiles, np.int_(data['TILEID']), fmt='%d')
    args.surveytiles = tmp_surveytiles

tmp_fiberstatusfile = None
if args.fibstatusfile is None:
    tmp_fiberstatusfile = os.path.join(args.outdir, "tmp_fiberstatus.txt")
    with open(tmp_fiberstatusfile, 'w') as fx:
        fx.write("FIBER LOCATION  X              Y             BROKEN STUCK START_DATE          END_DATE\n")
    args.fibstatusfile = tmp_fiberstatusfile

if args.starmask is None:
    args.starmask = 0
    for name in ['STD', 'STD_FSTAR', 'STD_WD',
                 'STD_FAINT', 'STD_FAINT_BEST',
                 'STD_BRIGHT', 'STD_BRIGHT_BEST']:
        if name in desi_mask.names():
            args.starmask |= desi_mask[name]

tmp_stdstarfile = None
if args.stdstar is None:
    #- These are currently required by C++ code,
    #- but may be more than really needed (e.g. BRICKNAME, MWS/BGS_TARGET)
    stdcolumns = ['TARGETID', 'RA', 'DEC', 'OBSCONDITIONS', 'SUBPRIORITY',
                  'BRICKNAME', 'DESI_TARGET', 'MWS_TARGET', 'BGS_TARGET']
    stdstars = fitsio.read(args.mtl, 'MTL', columns=stdcolumns)
    ii = (stdstars['DESI_TARGET'] & args.starmask) != 0
    stdstars = stdstars[ii]
    tmp_stdstarfile = os.path.join(args.outdir, 'tmp_stdstars.fits')
    args.stdstar = tmp_stdstarfile
    fitsio.write(tmp_stdstarfile, stdstars, extname='STD', clobber=True)
    del stdstars

if args.rundate is None:
    now = datetime.datetime.now()
    args.rundate = '{:04d}-{:02d}-{:02d}'.format(now.year, now.month, now.day)

if (args.telra is not None) and (args.teldec is not None) and \
   (args.tileid is not None) and (args.tileobsconditions is not None):
    from astropy.table import Table
    tiles = Table([[args.tileid], [args.telra], [args.teldec], [args.tileobsconditions], [1], [1]],
                  names=('TILEID', 'RA', 'DEC', 'OBSCONDITIONS', 'IN_DESI', 'PASS'))
    tiles.write(os.path.join(args.outdir, "tmp_footprint.fits"), overwrite=True)
    args.footprint = os.path.join(args.outdir, "tmp_footprint.fits")
    tmp_surveytiles = "tmp_surveytiles.txt"
    np.savetxt(tmp_surveytiles, [args.tileid], fmt='%d')
    args.surveytiles = tmp_surveytiles

# Make sure that output directory exists
if not os.path.isdir(args.outdir):
    os.makedirs(args.outdir)


def is_file_missing(filename):
    if not os.path.exists(filename):
        print('ERROR: file {} does not exist'.format(filename))
        sys.exit(1)

# Check if output files already exist
def check_existing_files(checkdir, overwrite):
    existing_files = False
    with open(args.surveytiles) as survey:
        for line in survey:
            line = line.strip()
            if line.startswith('#') or len(line)==0:
                continue
            tileid = int(line)
            for prefix in ('tile_', 'tile-', 'gfa-'):
                tilefile = os.path.join(checkdir, '{}{:05d}.fits'.format(prefix, tileid))
                if os.path.exists(tilefile):
                    if overwrite:
                        os.remove(tilefile)
                    else:
                        existing_files = True
                        print('ERROR: {} already exists'.format(tilefile))

    if existing_files:
        print('Remove pre-existing tile files, use --overwrite, or specify different --outdir')
        sys.exit(1)

def rewrite_fiberpos(fiberpos_fits_file, postype='POS'):
    data = Table.read(fiberpos_fits_file)
    data = data[data['DEVICE_TYPE']==postype]
    data = data[['FIBER', 'LOCATION', 'SPECTRO', 'X', 'Y', 'Z']]
    txtposfilename = os.path.join(args.outdir,"tmp_{}_pos.txt".format(postype))
    np.savetxt(txtposfilename, np.array(data).T, fmt='%d\t %d\t %d\t %f\t %f\t %f')
    return txtposfilename

#checks that all files exist
is_file_missing(args.mtl)
is_file_missing(args.sky)
is_file_missing(args.stdstar)
is_file_missing(args.fibstatusfile)
is_file_missing(args.surveytiles)
is_file_missing(args.footprint)
if args.gfafile is not None:
    is_file_missing(args.gfafile)



# tmp fiberpos
tmp_fiber_pos = rewrite_fiberpos(args.positioners)
tmp_fiber_sky = rewrite_fiberpos(args.positioners, postype='ETC')

# tmp output directories
tmp_targets_dir = tempfile.mkdtemp()
tmp_sky_dir = tempfile.mkdtemp()
tmp_gfa_dir = tempfile.mkdtemp()

if not os.path.exists(tmp_targets_dir):
    os.makedirs(tmp_targets_dir)

if not os.path.exists(tmp_sky_dir):
    os.makedirs(tmp_sky_dir)

if not os.path.exists(tmp_gfa_dir):
    os.makedirs(tmp_gfa_dir)

check_existing_files(args.outdir, args.overwrite)
check_existing_files(tmp_targets_dir, args.overwrite)

fiberassign_command ="fiberassign_exec --mtl {mtl}  --sky {sky} --stdstar {stdstar}  --fibstatusfile {fiberstatusfile}  \
            --outdir {outdir} \
            --surveytiles {surveytiles}  \
            --footprint {footprint}  \
            --positioners {positioners} \
            --starmask {starmask} \
            --rundate {rundate} \
            --nstarpetal {nstarpetal} \
            --nskypetal {nskypetal}"

# fiberassign 5k fibers for science targets, sky spectra, and standard stars
cmd = fiberassign_command.format(mtl=args.mtl, sky=args.sky, stdstar=args.stdstar, fiberstatusfile=args.fibstatusfile,
                                 outdir=tmp_targets_dir, surveytiles=args.surveytiles, starmask = args.starmask,
                                 footprint=args.footprint, positioners=tmp_fiber_pos, rundate=args.rundate,
                                 nstarpetal=args.nstarpetal, nskypetal=args.nskypetal)
print(cmd)
err = subprocess.call(cmd.split())
if err:
    print('fiberassign failed with error code {}; exiting'.format(err))
    sys.exit(err)

# Add new columns to fiberassign targets

#fiberassign 20 sky monitor fibers
cmd = fiberassign_command.format(mtl=args.sky, sky=args.sky, stdstar=args.sky, fiberstatusfile=args.fibstatusfile,
                                 outdir=tmp_sky_dir, surveytiles=args.surveytiles, starmask = args.starmask,
                                 footprint=args.footprint, positioners=tmp_fiber_sky, rundate=args.rundate,
                                 nstarpetal=args.nstarpetal, nskypetal=args.nskypetal)
print(cmd)
err = subprocess.call(cmd.split())
if err:
    print('fiberassign of sky monitor fibers failed with error code {}; exiting'.format(err))
    sys.exit(err)

# join targets+sky+gfa tiles
targets = glob.glob(os.path.join(tmp_targets_dir,'tile_*.fits'))
skys = glob.glob(os.path.join(tmp_sky_dir,'tile_*.fits'))

# Gather ID for target files
target_tile_id = {}
tile_id = []
for target_file in targets:
    fileid = target_file.split('/')[-1].split('_')[-1].split('.')[0]
    target_tile_id[fileid] = target_file
    tile_id.append(int(fileid))

# Gather TILEID for sky files
sky_tile_id = {}
for sky_file in skys:
    fileid = sky_file.split('/')[-1].split('_')[-1].split('.')[0]
    sky_tile_id[fileid] = sky_file

# Gather ID for gfa files
# GFA targets
if args.gfafile is not None:
    from desimodel.focalplane import GFALocations
    gfa = GFALocations()

    print('loading GFA file')
    gfa_data = fitsio.read(args.gfafile)
    footprint = fitsio.read(args.footprint)

    #- Trim to just the tiles that we are using here
    ii = np.in1d(footprint['TILEID'], np.array(tile_id))
    tiles = footprint[ii]
    
    #- Pre-filter what GFA targets cover what tiles with some buffer.
    #- find_points_in_tiles returns a list of lists;
    #- convert to dictionary of lists keyed by tileid
    print('Finding overlap of {} GFA targets on {} tiles'.format(
        len(gfa_data), len(tiles)))
    gfa_tile_indices = dict()
    ii = desimodel.footprint.find_points_in_tiles(tiles, gfa_data['RA'], gfa_data['DEC'], radius=1.8)
    for i, tileid in enumerate(tiles['TILEID']):
        gfa_tile_indices[tileid] = ii[i]

    print('Writing temporary GFA files')
    for telra, teldec, tileid in zip(tiles['RA'], tiles['DEC'], tiles['TILEID']):
        gfaout = os.path.join(tmp_gfa_dir, 'gfa-{:05d}.fits'.format(tileid))
        gfa_data_tmp = gfa.targets_on_gfa(telra, teldec, gfa_data[gfa_tile_indices[tileid]])
        t = Table(gfa_data_tmp)

        for oldname, newname in [
                ('TYPE', 'MORPHTYPE'),
                ('RA', 'TARGET_RA'),
                ('DEC', 'TARGET_DEC'),
                ('RA_IVAR', 'TARGET_RA_IVAR'),
                ('DEC_IVAR', 'TARGET_DEC_IVAR'),
            ]:
            if oldname in t.colnames:
                t.rename_column(oldname, newname)

        #- Add flags for ETC/GUIDE/FOCUS (0==good)
        flag = np.ones(len(t), dtype='i2')
        ii = (t['MORPHTYPE'] == 'PSF') | (t['MORPHTYPE'] == 'PSF ')
        if np.count_nonzero(ii) == 0:
            print('ERROR: no good GFA targets for '
                  'ETC/GUIDE/FOCUS on tile {}'.format(tileid))

        flag[ii] = 0
        t['ETC_FLAG'] = flag
        t['GUIDE_FLAG'] = flag
        t['FOCUS_FLAG'] = flag

        t.write(gfaout, overwrite=True)

    gfas = glob.glob(os.path.join(tmp_gfa_dir,'gfa-*.fits'))
    gfa_tile_id = {}
    for gfa_file in gfas:
        fileid = gfa_file.split('/')[-1].split('-')[-1].split('.')[0]
        gfa_tile_id[fileid] = gfa_file

    print('Done with GFAs')

def add_potential_data_columns(potential_data, fiberassign_data):
    potential_data.dtype.names = tuple(['TARGETID'])
    n_objects = len(potential_data)
    assert (np.sum(fiberassign_data['NUMTARGET'])==len(potential_data))
    fiber_array = np.ones(n_objects, dtype=np.int32) # 'FIBER'
    location_array = np.ones(n_objects, dtype=np.int32) # `LOCATION`

    for i in range(len(fiberassign_data)):
        min_i = fiberassign_data['NUMTARGET'][:i].sum()
        max_i = min_i + fiberassign_data['NUMTARGET'][i]
        fiber_array[min_i:max_i] = fiberassign_data['FIBER'][i]
        location_array[min_i:max_i] = fiberassign_data['LOCATION'][i]

    potential_data = np.lib.recfunctions.append_fields(potential_data, 'FIBER', fiber_array, dtypes=np.int32)
    potential_data = np.lib.recfunctions.append_fields(potential_data, 'LOCATION', location_array, dtypes=np.int32)  
    return potential_data
    

def add_fiber_data_columns(fiberassign_data, mtl_data,
        positioner_data, addcolumns=None):
    '''
    Augments fiberassing_data table with new columns

    Args:
        fiberassign_data: original table from fiber assignment
        mtl_data: Merged target list table covering this tile
        positioner_data: positioner locations table

    Options:
        addcolumns = list of new column names to add from mtl; default to all

    Returns table with new columns
    '''

    n_objects = len(fiberassign_data)

    # update DESI_TARGET for unassigned / broken / stuck fibers
    ii = (fiberassign_data['FIBERMASK'] != 0)
    fiberassign_data['DESI_TARGET'][ii] = desi_mask.NO_TARGET
    
    #print('  adding new columns by computation')
    q, s = desimodel.focalplane.xy2qs(fiberassign_data['XFOCAL_DESIGN'], fiberassign_data['YFOCAL_DESIGN'])
    fiberassign_data = np.lib.recfunctions.append_fields(fiberassign_data, 'DESIGN_Q', q, dtypes=np.float32)
    fiberassign_data = np.lib.recfunctions.append_fields(fiberassign_data, 'DESIGN_S', s, dtypes=np.float32)
    lambda_ref = np.ones(n_objects) * 5400.0
    fiberassign_data = np.lib.recfunctions.append_fields(fiberassign_data, 'LAMBDA_REF', lambda_ref, dtypes=np.float32)

    objtype = np.zeros(n_objects, dtype='S3')
    objtype[:] = 'TGT'
    isSky = (fiberassign_data['DESI_TARGET'] & desi_mask.SKY) != 0
    objtype[isSky] = 'SKY'
    badmask = desi_mask.mask('BAD_SKY|NO_TARGET|IN_BRIGHT_OBJECT')
    isBad = (fiberassign_data['DESI_TARGET'] & badmask) != 0
    objtype[isBad] = 'BAD'
    fiberassign_data = np.lib.recfunctions.append_fields(fiberassign_data, 'OBJTYPE', objtype, dtypes='S3')

    #print('  adding columns from positioner data')
    #- handle bytes (fitsio) vs. string (astropy)
    isPOS = (positioner_data['DEVICE_TYPE']==b'POS') | (positioner_data['DEVICE_TYPE']=='POS')
    positioner_data = positioner_data[isPOS]
    positioner_data = np.sort(positioner_data, order='FIBER')
    ii = np.in1d(positioner_data['FIBER'], fiber_data['FIBER'])

    fiberassign_data = np.lib.recfunctions.append_fields(fiberassign_data, 'PETAL_LOC', positioner_data[ii]['PETAL'],dtypes=np.int16)
    fiberassign_data = np.lib.recfunctions.append_fields(fiberassign_data, 'DEVICE_LOC', positioner_data[ii]['DEVICE'],dtypes=np.int32)   
    
    #print('  adding columns from mtl data')
    if addcolumns is None:
        addcolumns = mtl_data.dtype.names

    columns = list()
    for c in addcolumns:
        if (c not in fiberassign_data.dtype.names) or c == 'TARGETID':
            columns.append(c)

    #print('Tile ID {} Total of MTL points {}. Total of fiberassign_data {}'.format(
    #        tile_data['TILEID'], len(mtl_data), len(fiberassign_data)))
    fiberassign_data = join(fiberassign_data, mtl_data[columns], join_type='left', keys='TARGETID')
    if fiberassign_data.masked:
        unmatched = fiberassign_data['SUBPRIORITY'].mask
        fiberassign_data['SUBPRIORITY'][unmatched] = 1
    
    return np.array(fiberassign_data)

def add_sky_data_columns(sky_data, positioner_data):
    q, s = desimodel.focalplane.xy2qs(sky_data['XFOCAL_DESIGN'], sky_data['YFOCAL_DESIGN'])
    sky_data = np.lib.recfunctions.append_fields(sky_data, 'DESIGN_Q', q, dtypes=np.float32)
    sky_data = np.lib.recfunctions.append_fields(sky_data, 'DESIGN_S', s, dtypes=np.float32)

    isPOS = (positioner_data['DEVICE_TYPE']==b'ETC') | (positioner_data['DEVICE_TYPE']=='ETC')
    positioner_data = positioner_data[isPOS]
    positioner_data = np.sort(positioner_data, order='FIBER')
    ii = np.in1d(positioner_data['FIBER'], sky_data['FIBER'])

    sky_data = np.lib.recfunctions.append_fields(sky_data, 'PETAL_LOC', positioner_data[ii]['PETAL'], dtypes=np.int16)
    sky_data = np.lib.recfunctions.append_fields(sky_data, 'DEVICE_LOC', positioner_data[ii]['DEVICE'], dtypes=np.int32)

    return np.array(sky_data)

def make_target_hdu_data(fiberassign_data, mtl_data):
    new_target_data = fiberassign_data[['TARGETID']]
    n_objects = len(new_target_data)
    
    # print('  adding all columns from mtl data in make_target_hdu_data')
    # print('  Total of MTL points {}. Total of new_target_data {}'.format(
    #         len(mtl_data), len(new_target_data)))

    new_target_data = join(new_target_data, mtl_data, join_type='left', keys='TARGETID')
    if new_target_data.masked:
        unmatched = new_target_data['SUBPRIORITY'].mask
        new_target_data['SUBPRIORITY'][unmatched] = 1
    
    return np.array(new_target_data)

def rename_columns(data, oldnew):
    '''
    Modified column names in data

    Args:
        data: numpy structured array
        oldnew: list of tuples (oldname, newname)

    Modifies `data` column names in-place; does not change data

    Note: it is ok if an oldname isn't in the data column names
    '''
    colnames = list(data.dtype.names)
    for oldname, newname in oldnew:
        if oldname in colnames:
            i = colnames.index(oldname)
            colnames[i] = newname

    data.dtype.names = tuple(colnames)

#-------------------------------------------------------------------------
mtl_data = fitsio.read(args.mtl)
sky_data = fitsio.read(args.sky)
positioner_data = fitsio.read(args.positioners)
footprint = fitsio.read(args.footprint)

#- Load DESI tiles to provide header keywords; convert to dict for fast lookup
tiles = desimodel.io.load_tiles(tilesfile=args.footprint)
tileinfo = dict()
for i in range(len(tiles)):
    tileid = tiles['TILEID'][i]
    tileinfo[tileid] = tiles[i]

#- Pre-filter what targets cover what tiles with some buffer.
#- find_points_in_tiles returns a list of lists;
#- convert to dictionary of lists keyed by tileid
mtl_tile_indices = dict()
ii = desimodel.footprint.find_points_in_tiles(footprint, mtl_data['RA'], mtl_data['DEC'], radius=1.8)
for i, tileid in enumerate(footprint['TILEID']):
    mtl_tile_indices[tileid] = ii[i]

for sky_id in sky_tile_id.keys():
    if sky_id in target_tile_id.keys():
        tileid = int(sky_id)
        print('rewriting tilefile for tileid {}'.format(sky_id))
        sky_data = fitsio.read(sky_tile_id[sky_id])
        fiber_data = fitsio.read(target_tile_id[sky_id], ext=1)
        potential_data = fitsio.read(target_tile_id[sky_id], ext=2)

        target_data = make_target_hdu_data(fiber_data, mtl_data[mtl_tile_indices[int(sky_id)]])
        fiber_data = add_fiber_data_columns(fiber_data, mtl_data[mtl_tile_indices[int(sky_id)]], positioner_data)

        sky_data = add_sky_data_columns(sky_data, positioner_data)
        ii = np.argsort(sky_data['FIBER'])
        sky_data = sky_data[ii]

        #- The joins in make_target_hdu_data and add_fiber_data_columns
        #- sort by TARGETID; get back to FIBERID sorting to be able to
        #- interpret the potential_data list
        assert np.all(target_data['TARGETID'] == fiber_data['TARGETID'])
        ii = np.argsort(fiber_data['FIBER'])
        target_data = target_data[ii]
        fiber_data = fiber_data[ii]
        assert np.all(target_data['TARGETID'] == fiber_data['TARGETID'])

        #- Unpack the potential targetids into FIBER LOCATION TARGETID
        potential_data = add_potential_data_columns(potential_data, fiber_data)

        #- Rename some columns (leave C++ alone; it is being refactored)
        oldnew = [
            #- target catalog input renames
            ('RA', 'TARGET_RA'),
            ('DEC', 'TARGET_DEC'),
            ('RA_IVAR', 'TARGET_RA_IVAR'),
            ('DEC_IVAR', 'TARGET_DEC_IVAR'),
            #- C++ output renames
            ('XFOCAL_DESIGN', 'DESIGN_X'),
            ('YFOCAL_DESIGN', 'DESIGN_Y'),
            ('FIBERMASK', 'FIBERSTATUS'),
            ]
        rename_columns(fiber_data, oldnew)
        rename_columns(sky_data, oldnew)

        header = list()
        header.append(dict(name='REQRA', value=tileinfo[tileid]['RA'],
            comment = 'Requested pointing RA [degrees]'))
        header.append(dict(name='REQDEC', value=tileinfo[tileid]['DEC'],
            comment = 'Requested pointing declination [degrees]'))
        header.append(dict(name='TILERA', value=tileinfo[tileid]['RA'],
            comment = 'Tile RA [degrees]'))
        header.append(dict(name='TILEDEC', value=tileinfo[tileid]['DEC'],
            comment = 'Tile declination [degrees]'))
        header.append(dict(name='FIELDNUM', value=0,
            comment = 'Field configuration number'))
        header.append(dict(name='TILEID', value=sky_id,
            comment = 'DESI tile ID'))

        #- Blank HDU 0 with just header keywords
        tileout = os.path.join(args.outdir, 'tile-{}.fits'.format(sky_id))
        fitsio.write(tileout, None, extname='PRIMARY',
                     header=header, clobber=True)

        #- Write FIBERASSIGN table with the same header to HDU 1
        fitsio.write(tileout, fiber_data, extname='FIBERASSIGN', header=header)

        #- Proceed with other HDUs
        if args.gfafile is not None:
            gfa_data = fitsio.read(gfa_tile_id[sky_id])
            fitsio.write(tileout, gfa_data, extname='GFA_TARGETS')

        fitsio.write(tileout, sky_data, extname='SKY_MONITOR')
        fitsio.write(tileout, target_data, extname='TARGETS')
        fitsio.write(tileout, potential_data, extname='POTENTIAL_ASSIGNMENTS')


# remove tmp files
if args.cleanup:
    shutil.rmtree(tmp_targets_dir)
    shutil.rmtree(tmp_sky_dir)
    shutil.rmtree(tmp_gfa_dir)
    os.remove(tmp_fiber_pos)
    os.remove(tmp_fiber_sky)
    if tmp_fiberstatusfile is not None:
        os.remove(tmp_fiberstatusfile)
    if tmp_surveytiles is not None:
        os.remove(tmp_surveytiles)
    if tmp_stdstarfile is not None:
        os.remove(tmp_stdstarfile)

else:
    print('tmp_targets_dir {}'.format(tmp_targets_dir))
    print('tmp_sky_dir {}'.format(tmp_sky_dir))
    print('tmp_gfa_dir {}'.format(tmp_gfa_dir))
